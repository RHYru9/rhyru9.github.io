-- ========================================
-- 🎲 ULTIMATE RNG SYSTEM ANALYZER V2.0
-- Hydrogen App Compatible Edition
-- Auto-dumps to Hydrogen/dump/ folder
-- ========================================

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")
local StarterGui = game:GetService("StarterGui")
local Workspace = game:GetService("Workspace")

print([[
╔═══════════════════════════════════════════╗
║  🎲 ULTIMATE RNG ANALYZER V2.0 🎲        ║
║  Hydrogen App Compatible Edition         ║
║  Auto-dumps to Hydrogen/dump/            ║
╚═══════════════════════════════════════════╝
]])

-- ========================================
-- CONFIGURATION
-- ========================================

local Config = {
    maxDepth = 10,
    maxTableSize = 1000,
    scanAllServices = true,
    deepFunctionAnalysis = true,
    detectPatterns = true,
    extractConstants = true,
    hookFunctions = true,
    monitorRemotes = true,
    analyzeLocalScripts = true,
    extractStrings = true,
    findHiddenModules = true,
    debugMode = false,
    -- Hydrogen specific paths
    dumpFolder = "dump/",
    subFolders = {
        modules = "dump/Modules/",
        functions = "dump/Functions/",
        tables = "dump/Tables/",
        patterns = "dump/Patterns/",
        exploits = "dump/Exploits/",
        remotes = "dump/Remotes/",
        reports = "dump/Reports/"
    }
}

-- ========================================
-- HYDROGEN FILE SYSTEM
-- ========================================

local FileSystem = {}

function FileSystem:Init()
    -- Check Hydrogen file functions
    self.canWrite = writefile ~= nil
    self.canMakeFolder = makefolder ~= nil
    self.canListFiles = listfiles ~= nil
    self.canDeleteFile = delfile ~= nil
    self.canReadFile = readfile ~= nil
    
    if not self.canWrite then
        warn("⚠️ writefile() not supported!")
        return false
    end
    
    print("✅ Hydrogen file system initialized")
    print("📂 Dump location: Hydrogen/" .. Config.dumpFolder)
    return true
end

function FileSystem:CreateFolders()
    if not self.canMakeFolder then
        warn("⚠️ makefolder() not supported, files will be in root")
        return
    end
    
    -- Create main dump folder
    pcall(function() makefolder(Config.dumpFolder) end)
    
    -- Create subfolders
    for name, path in pairs(Config.subFolders) do
        pcall(function() 
            makefolder(path)
            print("📁 Created: " .. path)
        end)
    end
    
    print("✅ Folder structure created\n")
end

function FileSystem:WriteJSON(filename, data)
    if not self.canWrite then return false end
    
    local success, json = pcall(function()
        return HttpService:JSONEncode(data)
    end)
    
    if success and json then
        local path = Config.dumpFolder .. filename
        pcall(function()
            writefile(path, json)
            print(string.format("💾 Saved: %s (%.2f KB)", filename, #json / 1024))
        end)
        return true
    else
        warn("❌ Failed to encode JSON: " .. filename)
        return false
    end
end

function FileSystem:WriteLua(filename, data, varName)
    if not self.canWrite then return false end
    
    varName = varName or "Data"
    
    local function serialize(tbl, indent, maxItems)
        indent = indent or 0
        maxItems = maxItems or 100
        local s = string.rep("  ", indent)
        local lines = {"{"}
        
        local count = 0
        for k, v in pairs(tbl) do
            count = count + 1
            if count > maxItems then
                table.insert(lines, s .. '  ["__TRUNCATED__"] = "Truncated after ' .. maxItems .. ' items",')
                break
            end
            
            local key
            if type(k) == "string" then
                key = string.format('["%s"]', k:gsub('"', '\\"'))
            else
                key = string.format("[%s]", tostring(k))
            end
            
            local value
            if type(v) == "table" then
                if indent < 5 then -- Limit recursion
                    value = serialize(v, indent + 1, 50)
                else
                    value = '"{...}"'
                end
            elseif type(v) == "string" then
                value = string.format('"%s"', v:gsub('"', '\\"'):sub(1, 200))
            elseif type(v) == "number" or type(v) == "boolean" then
                value = tostring(v)
            else
                value = string.format('"%s"', tostring(v))
            end
            
            table.insert(lines, string.format("%s  %s = %s,", s, key, value))
        end
        
        table.insert(lines, s .. "}")
        return table.concat(lines, "\n")
    end
    
    local content = string.format("-- Auto-generated by Ultimate RNG Analyzer\n-- %s\n\nlocal %s = %s\n\nreturn %s", 
        os.date("%Y-%m-%d %H:%M:%S"), 
        varName, 
        serialize(data), 
        varName
    )
    
    local path = Config.dumpFolder .. filename
    pcall(function()
        writefile(path, content)
        print(string.format("💾 Saved: %s (%.2f KB)", filename, #content / 1024))
    end)
    
    return true
end

function FileSystem:WriteText(filename, text)
    if not self.canWrite then return false end
    
    local path = Config.dumpFolder .. filename
    pcall(function()
        writefile(path, text)
        print(string.format("💾 Saved: %s (%.2f KB)", filename, #text / 1024))
    end)
    
    return true
end

-- ========================================
-- ADVANCED UTILITIES
-- ========================================

local Utils = {}

function Utils:SafeRequire(module)
    if not module or not module:IsA("ModuleScript") then return nil end
    
    local success, result = pcall(function()
        return require(module)
    end)
    
    if success and result then
        return result
    end
    return nil
end

function Utils:GetFunctionSource(func)
    if not func or type(func) ~= "function" then return nil end
    
    local success, info = pcall(debug.getinfo, func)
    if not success then return nil end
    
    return {
        source = info.source or "Unknown",
        short_src = info.short_src or "Unknown",
        linedefined = info.linedefined or 0,
        lastlinedefined = info.lastlinedefined or 0,
        numparams = info.nparams or 0,
        isvararg = info.isvararg or false,
        what = info.what or "Lua",
        name = info.name or "anonymous"
    }
end

function Utils:ExtractUpvalues(func)
    local upvalues = {}
    local i = 1
    
    while true do
        local success, name, value = pcall(debug.getupvalue, func, i)
        if not success or not name then break end
        
        upvalues[name] = {
            type = type(value),
            value = self:SerializeValue(value, 1)
        }
        i = i + 1
    end
    
    return upvalues
end

function Utils:ExtractConstants(func)
    local constants = {}
    
    if not debug.getconstant then
        return constants
    end
    
    local i = 1
    while i < 100 do -- Limit to 100 constants
        local success, constant = pcall(debug.getconstant, func, i)
        if not success then break end
        
        if constant ~= nil then
            table.insert(constants, {
                index = i,
                type = type(constant),
                value = self:SerializeValue(constant, 0)
            })
        end
        i = i + 1
    end
    
    return constants
end

function Utils:AnalyzeFunctionBytecode(func)
    local analysis = {
        source = self:GetFunctionSource(func),
        upvalues = self:ExtractUpvalues(func),
        constants = Config.extractConstants and self:ExtractConstants(func) or {},
        callsRandom = false,
        callsRemote = false,
        modifiesGlobals = false,
        complexity = 0
    }
    
    -- Pattern detection in constants
    for _, constant in ipairs(analysis.constants) do
        if type(constant.value) == "string" then
            local str = tostring(constant.value):lower()
            if str:find("random") or str:find("rng") or str:find("roll") then
                analysis.callsRandom = true
            end
            if str:find("remote") or str:find("invoke") or str:find("fire") then
                analysis.callsRemote = true
            end
        end
    end
    
    -- Calculate complexity
    analysis.complexity = #analysis.constants + Utils:CountTable(analysis.upvalues)
    
    return analysis
end

function Utils:SerializeValue(value, depth, seen)
    depth = depth or 0
    seen = seen or {}
    
    if depth > Config.maxDepth then return "MAX_DEPTH" end
    if seen[value] then return "CIRCULAR_REF" end
    
    local vtype = type(value)
    
    if vtype == "table" then
        seen[value] = true
        local items = {}
        local count = 0
        
        for k, v in pairs(value) do
            count = count + 1
            if count > Config.maxTableSize then
                items["__TRUNCATED__"] = "..."
                break
            end
            
            local key = tostring(k)
            items[key] = self:SerializeValue(v, depth + 1, seen)
        end
        
        return items
    elseif vtype == "function" then
        if Config.deepFunctionAnalysis and depth < 2 then
            return self:AnalyzeFunctionBytecode(value)
        else
            return {type = "function", name = tostring(value)}
        end
    elseif vtype == "userdata" then
        local success, str = pcall(tostring, value)
        return {type = "userdata", value = success and str or "Unknown"}
    elseif vtype == "number" or vtype == "boolean" then
        return value
    elseif vtype == "string" then
        return value:sub(1, 200)
    else
        return tostring(value)
    end
end

function Utils:GetInstancePath(instance)
    local path = {}
    local current = instance
    
    while current and current ~= game do
        table.insert(path, 1, current.Name)
        current = current.Parent
    end
    
    return table.concat(path, ".")
end

function Utils:CountTable(tbl)
    local count = 0
    for _ in pairs(tbl) do count = count + 1 end
    return count
end

-- ========================================
-- UNIVERSAL MODULE SCANNER
-- ========================================

local ModuleScanner = {}

function ModuleScanner:ScanAllServices()
    print("\n🌐 Scanning ALL game services...\n")
    
    local services = {
        game.ReplicatedStorage,
        game.ReplicatedFirst,
        game.StarterGui,
        game.StarterPack,
        game.StarterPlayer,
        game.Lighting,
        game.Workspace
    }
    
    -- Try to access ServerStorage and ServerScriptService (client might not have access)
    pcall(function()
        table.insert(services, game.ServerStorage)
    end)
    pcall(function()
        table.insert(services, game.ServerScriptService)
    end)
    
    local modules = {}
    
    for _, service in ipairs(services) do
        local serviceName = service.Name
        local success = pcall(function()
            for _, descendant in ipairs(service:GetDescendants()) do
                if descendant:IsA("ModuleScript") then
                    local module = Utils:SafeRequire(descendant)
                    if module then
                        modules[descendant.Name] = {
                            module = module,
                            instance = descendant,
                            service = serviceName,
                            path = Utils:GetInstancePath(descendant)
                        }
                        print(string.format("  [✓] %s: %s", serviceName, descendant.Name))
                    end
                end
            end
        end)
        
        if not success then
            print(string.format("  [⚠️] Cannot access: %s", serviceName))
        end
    end
    
    print(string.format("\n✅ Found %d modules total\n", Utils:CountTable(modules)))
    
    return modules
end

function ModuleScanner:ScanRemoteEvents()
    print("\n📡 Scanning RemoteEvents/Functions...\n")
    
    local remotes = {
        events = {},
        functions = {}
    }
    
    for _, service in ipairs({game.ReplicatedStorage, game.Workspace}) do
        pcall(function()
            for _, descendant in ipairs(service:GetDescendants()) do
                if descendant:IsA("RemoteEvent") then
                    remotes.events[descendant.Name] = {
                        path = Utils:GetInstancePath(descendant),
                        instance = descendant,
                        parent = descendant.Parent.Name
                    }
                    print(string.format("  [📤] RemoteEvent: %s", descendant.Name))
                elseif descendant:IsA("RemoteFunction") then
                    remotes.functions[descendant.Name] = {
                        path = Utils:GetInstancePath(descendant),
                        instance = descendant,
                        parent = descendant.Parent.Name
                    }
                    print(string.format("  [🔄] RemoteFunction: %s", descendant.Name))
                end
            end
        end)
    end
    
    print(string.format("\n✅ Found %d remotes total\n", 
        Utils:CountTable(remotes.events) + Utils:CountTable(remotes.functions)))
    
    return remotes
end

-- ========================================
-- ADVANCED RNG ANALYZER
-- ========================================

local RNGAnalyzer = {}

function RNGAnalyzer:DeepAnalyze(module, name, depth)
    depth = depth or 0
    if depth > 3 then return {} end
    
    print(string.format("%s📊 Analyzing: %s", string.rep("  ", depth), name))
    
    local analysis = {
        name = name,
        depth = depth,
        functions = {},
        tables = {},
        numbers = {},
        strings = {},
        patterns = {},
        metadata = {}
    }
    
    local processed = 0
    for key, value in pairs(module) do
        processed = processed + 1
        if processed > 500 then -- Limit processing
            analysis.metadata.truncated = true
            break
        end
        
        local vtype = type(value)
        
        if vtype == "function" then
            analysis.functions[key] = Utils:AnalyzeFunctionBytecode(value)
        elseif vtype == "table" and depth < 2 then
            local tableAnalysis = self:AnalyzeTable(value, key, depth + 1)
            analysis.tables[key] = tableAnalysis
        elseif vtype == "number" then
            analysis.numbers[key] = value
        elseif vtype == "string" then
            analysis.strings[key] = value:sub(1, 100)
            
            local valueLower = value:lower()
            if valueLower:find("weight") then
                analysis.patterns.hasWeights = true
            end
            if valueLower:find("luck") then
                analysis.patterns.hasLuck = true
            end
            if valueLower:find("rare") or valueLower:find("legendary") then
                analysis.patterns.hasRarity = true
            end
        end
    end
    
    return analysis
end

function RNGAnalyzer:AnalyzeTable(tbl, name, depth)
    depth = depth or 0
    if depth > Config.maxDepth then return {truncated = true} end
    
    local analysis = {
        name = name,
        size = 0,
        hasWeights = false,
        hasMultipliers = false,
        hasProbabilities = false,
        isArray = true,
        isWeightTable = false,
        keys = {},
        values = {}
    }
    
    local arrayIndex = 1
    
    for k, v in pairs(tbl) do
        analysis.size = analysis.size + 1
        if analysis.size > 100 then break end -- Limit
        
        if k ~= arrayIndex then
            analysis.isArray = false
        end
        arrayIndex = arrayIndex + 1
        
        local keyLower = tostring(k):lower()
        if keyLower:find("weight") or keyLower == "w" then
            analysis.hasWeights = true
            analysis.isWeightTable = true
        end
        if keyLower:find("chance") or keyLower:find("probability") then
            analysis.hasProbabilities = true
            analysis.isWeightTable = true
        end
        if keyLower:find("multiplier") or keyLower:find("mult") then
            analysis.hasMultipliers = true
        end
        
        table.insert(analysis.keys, tostring(k))
        
        if type(v) == "number" then
            table.insert(analysis.values, {key = k, value = v, type = "number"})
        end
    end
    
    return analysis
end

function RNGAnalyzer:FindRNGPatterns(module, name)
    print(string.format("🎲 Finding RNG patterns in: %s", name))
    
    local patterns = {
        name = name,
        usesRandom = false,
        usesRandomNew = false,
        usesMathRandom = false,
        usesWeights = false,
        usesSeeds = false,
        rngFunctions = {},
        weightTables = {},
        seedVariables = {}
    }
    
    for key, value in pairs(module) do
        if type(value) == "function" then
            local analysis = Utils:AnalyzeFunctionBytecode(value)
            
            for _, constant in ipairs(analysis.constants) do
                if type(constant.value) == "string" then
                    local str = tostring(constant.value):lower()
                    
                    if str:find("random%.new") then
                        patterns.usesRandomNew = true
                        table.insert(patterns.rngFunctions, {
                            name = key,
                            type = "Random.new"
                        })
                    elseif str:find("math%.random") then
                        patterns.usesMathRandom = true
                        table.insert(patterns.rngFunctions, {
                            name = key,
                            type = "math.random"
                        })
                    end
                    
                    if str:find("seed") then
                        patterns.usesSeeds = true
                        table.insert(patterns.seedVariables, key)
                    end
                end
            end
            
            for upname, upval in pairs(analysis.upvalues) do
                local upnameLower = upname:lower()
                if upnameLower:find("random") or upnameLower:find("rng") then
                    patterns.usesRandom = true
                end
                if upnameLower:find("seed") then
                    patterns.usesSeeds = true
                end
            end
        elseif type(value) == "table" then
            local tableAnalysis = self:AnalyzeTable(value, key)
            if tableAnalysis.isWeightTable then
                patterns.usesWeights = true
                patterns.weightTables[key] = tableAnalysis
            end
        end
    end
    
    return patterns
end

-- ========================================
-- PATTERN DETECTOR
-- ========================================

local PatternDetector = {}

function PatternDetector:DetectGameType(allModules)
    print("\n🎮 Detecting game type...\n")
    
    local patterns = {
        fishing = 0,
        gacha = 0,
        simulator = 0,
        tycoon = 0,
        rpg = 0,
        tower_defense = 0,
        obby = 0
    }
    
    local keywords = {
        fishing = {"fish", "rod", "bait", "catch", "reel", "aqua"},
        gacha = {"summon", "pull", "banner", "rate", "pity", "wish"},
        simulator = {"rebirth", "pet", "egg", "hatch", "upgrade", "auto"},
        tycoon = {"cash", "income", "purchase", "unlock", "dropper"},
        rpg = {"quest", "level", "exp", "skill", "stat", "class"},
        tower_defense = {"tower", "enemy", "wave", "defense", "upgrade"},
        obby = {"checkpoint", "stage", "jump", "obstacle"}
    }
    
    for moduleName, _ in pairs(allModules) do
        local nameLower = moduleName:lower()
        
        for gameType, wordList in pairs(keywords) do
            for _, keyword in ipairs(wordList) do
                if nameLower:find(keyword) then
                    patterns[gameType] = patterns[gameType] + 1
                end
            end
        end
    end
    
    local maxScore = 0
    local gameType = "unknown"
    
    for gtype, score in pairs(patterns) do
        if score > maxScore then
            maxScore = score
            gameType = gtype
        end
    end
    
    print(string.format("  [🎯] Detected: %s (confidence: %d)", gameType, maxScore))
    
    return {
        type = gameType,
        confidence = maxScore,
        allScores = patterns
    }
end

function PatternDetector:FindExploitPatterns(analysisData)
    print("\n🔓 Finding exploit patterns...\n")
    
    local exploits = {
        clientSideRNG = {},
        predictableSeeds = {},
        manipulableWeights = {},
        exposedConstants = {},
        recommendations = {}
    }
    
    for moduleName, data in pairs(analysisData.modules or {}) do
        if data.patterns then
            if data.patterns.usesMathRandom then
                table.insert(exploits.clientSideRNG, {
                    module = moduleName,
                    risk = "CRITICAL",
                    reason = "Uses math.random - completely predictable",
                    exploit = "Can be predicted and manipulated"
                })
                print(string.format("  [🔴] CRITICAL: %s uses math.random", moduleName))
            end
            
            if data.patterns.usesSeeds then
                table.insert(exploits.predictableSeeds, {
                    module = moduleName,
                    risk = "HIGH",
                    reason = "Uses seed-based RNG",
                    exploit = "Seed can be predicted if algorithm is known"
                })
                print(string.format("  [🟠] HIGH: %s uses seeds", moduleName))
            end
            
            if data.patterns.usesWeights and Utils:CountTable(data.patterns.weightTables) > 0 then
                table.insert(exploits.manipulableWeights, {
                    module = moduleName,
                    risk = "MEDIUM",
                    reason = "Weight tables accessible from client",
                    exploit = "Can modify weights before calculation"
                })
                print(string.format("  [🟡] MEDIUM: %s has exposed weights", moduleName))
            end
        end
        
        if data.numbers then
            for key, value in pairs(data.numbers) do
                if value >= 0.01 and value <= 100 then
                    table.insert(exploits.exposedConstants, {
                        module = moduleName,
                        constant = key,
                        value = value,
                        risk = "LOW"
                    })
                end
            end
        end
    end
    
    table.insert(exploits.recommendations, "Move ALL RNG calculations to server-side")
    table.insert(exploits.recommendations, "Use cryptographically secure RNG (Random.new)")
    table.insert(exploits.recommendations, "Never expose weight tables to client")
    table.insert(exploits.recommendations, "Validate ALL user inputs server-side")
    table.insert(exploits.recommendations, "Implement rate limiting on critical actions")
    
    return exploits
end

-- ========================================
-- MAIN EXECUTION ENGINE
-- ========================================

local function ExecuteAnalysis()
    print("\n🚀 Starting ULTIMATE analysis...\n")
    print("📂 Dumping to: Hydrogen/" .. Config.dumpFolder .. "\n")
    
    local startTime = tick()
    
    -- Initialize file system
    if not FileSystem:Init() then
        warn("Cannot save files - analysis will stop")
        return nil
    end
    
    FileSystem:CreateFolders()
    
    -- Scan everything
    print(string.rep("=", 60))
    print("PHASE 1: COMPREHENSIVE SCANNING")
    print(string.rep("=", 60))
    
    local allModules = ModuleScanner:ScanAllServices()
    local remotes = Config.monitorRemotes and ModuleScanner:ScanRemoteEvents() or {}
    
    -- Detect game type
    local gameType = PatternDetector:DetectGameType(allModules)
    
    -- Deep analysis
    print("\n" .. string.rep("=", 60))
    print("PHASE 2: DEEP ANALYSIS")
    print(string.rep("=", 60) .. "\n")
    
    local fullAnalysis = {
        metadata = {
            timestamp = os.date("%Y-%m-%d %H:%M:%S"),
            executor = "Hydrogen",
            gameName = game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Name or "Unknown",
            placeId = game.PlaceId,
            gameType = gameType,
            analysisTime = 0
        },
        modules = {},
        patterns = {},
        remotes = remotes,
        exploits = {},
        statistics = {
            totalModules = 0,
            totalFunctions = 0,
            totalRemotes = 0
        }
    }
    
    -- Analyze each module
    local moduleCount = 0
    for moduleName, moduleData in pairs(allModules) do
        moduleCount = moduleCount + 1
        
        fullAnalysis.modules[moduleName] = RNGAnalyzer:DeepAnalyze(moduleData.module, moduleName)
        fullAnalysis.patterns[moduleName] = RNGAnalyzer:FindRNGPatterns(moduleData.module, moduleName)
        
        -- Save individual module analysis
        local safeName = moduleName:gsub("[^%w]", "_")
        FileSystem:WriteJSON("Modules/" .. safeName .. ".json", fullAnalysis.modules[moduleName])
        FileSystem:WriteJSON("Patterns/" .. safeName .. ".json", fullAnalysis.patterns[moduleName])
        
        fullAnalysis.statistics.totalModules = moduleCount
        
        if fullAnalysis.modules[moduleName].functions then
            for _ in pairs(fullAnalysis.modules[moduleName].functions) do
                fullAnalysis.statistics.totalFunctions = fullAnalysis.statistics.totalFunctions + 1
            end
        end
    end
    
    fullAnalysis.statistics.totalRemotes = Utils:CountTable(remotes.events) + Utils:CountTable(remotes.functions)
    
    -- Find exploits
    print("\n" .. string.rep("=", 60))
    print("PHASE 3: EXPLOIT DETECTION")
    print(string.rep("=", 60))
    
    fullAnalysis.exploits = PatternDetector:FindExploitPatterns(fullAnalysis)
    
    -- Calculate analysis time
    fullAnalysis.metadata.analysisTime = math.floor((tick() - startTime) * 100) / 100
    
    -- Save everything
    print("\n" .. string.rep("=", 60))
    print("PHASE 4: SAVING RESULTS")
    print(string.rep("=", 60) .. "\n")
    
    FileSystem:WriteJSON("complete_analysis.json", fullAnalysis)
    FileSystem:WriteLua("complete_analysis.lua", fullAnalysis, "CompleteAnalysis")
    FileSystem:WriteJSON("Exploits/all_vulnerabilities.json", fullAnalysis.exploits)
    FileSystem:WriteJSON("Remotes/remote_events.json", remotes)
    
    -- Generate text report
    local report = string.format([[
════════════════════════════════════════════════════════
         ULTIMATE ANALYSIS COMPREHENSIVE REPORT
════════════════════════════════════════════════════════

Generated: %s
Game: %s
Place ID: %s
Game Type: %s (confidence: %d)
Analysis Time: %.2fs

════════════════════════════════════════════════════════
STATISTICS
════════════════════════════════════════════════════════
Total Modules: %d
Total Functions: %d
Total Remotes: %d

════════════════════════════════════════════════════════
VULNERABILITIES
════════════════════════════════════════════════════════
Critical: %d
High: %d
Medium: %d
Low: %d

════════════════════════════════════════════════════════
All files saved to: Hydrogen/%s
════════════════════════════════════════════════════════
]], 
        fullAnalysis.metadata.timestamp,
        fullAnalysis.metadata.gameName,
        fullAnalysis.metadata.placeId,
        gameType.type,
        gameType.confidence,
        fullAnalysis.metadata.analysisTime,
        fullAnalysis.statistics.totalModules,
        fullAnalysis.statistics.totalFunctions,
        fullAnalysis.statistics.totalRemotes,
        #fullAnalysis.exploits.clientSideRNG,
        #fullAnalysis.exploits.predictableSeeds,
        #fullAnalysis.exploits.manipulableWeights,
        #fullAnalysis.exploits.exposedConstants,
        Config.dumpFolder
    )
    
    FileSystem:WriteText("Reports/analysis_report_" .. os.date("%Y%m%d_%H%M%S") .. ".txt", report)
    
    -- Print final summary
    print("\n" .. string.rep("=", 60))
    print("✅ ULTIMATE ANALYSIS COMPLETE!")
    print(string.rep("=", 60))
    print(report)
    
    if setclipboard then
        setclipboard(report)
        print("\n✅ Summary copied to clipboard!")
    end
    
    return fullAnalysis
end

-- ========================================
-- GLOBAL API
-- ========================================

_G.UltimateAnalyzer = {
    -- Core functions
    Run = ExecuteAnalysis,
    
    -- Utils
    Utils = Utils,
    FileSystem = FileSystem,
    
    -- Scanners
    ModuleScanner = ModuleScanner,
    
    -- Analyzers
    RNGAnalyzer = RNGAnalyzer,
    PatternDetector = PatternDetector,
    
    -- Quick functions
    ListAllModules = function()
        local modules = ModuleScanner:ScanAllServices()
        local list = {}
        for name, _ in pairs(modules) do
            table.insert(list, name)
        end
        table.sort(list)
        return list
    end,
    
    FindWeightTables = function()
        local modules = ModuleScanner:ScanAllServices()
        local weightTables = {}
        
        for moduleName, moduleData in pairs(modules) do
            local patterns = RNGAnalyzer:FindRNGPatterns(moduleData.module, moduleName)
            if patterns.usesWeights then
                weightTables[moduleName] = patterns.weightTables
            end
        end
        
        return weightTables
    end,
    
    FindRNGFunctions = function()
        local modules = ModuleScanner:ScanAllServices()
        local rngFunctions = {}
        
        for moduleName, moduleData in pairs(modules) do
            local patterns = RNGAnalyzer:FindRNGPatterns(moduleData.module, moduleName)
            if #patterns.rngFunctions > 0 then
                rngFunctions[moduleName] = patterns.rngFunctions
            end
        end
        
        return rngFunctions
    end,
    
    MonitorRemotes = function()
        return ModuleScanner:ScanRemoteEvents()
    end,
    
    AnalyzeModule = function(moduleName)
        local modules = ModuleScanner:ScanAllServices()
        if modules[moduleName] then
            local analysis = RNGAnalyzer:DeepAnalyze(modules[moduleName].module, moduleName)
            local patterns = RNGAnalyzer:FindRNGPatterns(modules[moduleName].module, moduleName)
            return {analysis = analysis, patterns = patterns}
        end
        return nil
    end,
    
    GetModuleByName = function(name)
        local modules = ModuleScanner:ScanAllServices()
        return modules[name]
    end,
    
    -- Quick scan modes
    QuickScan = function()
        print("\n⚡ Quick Scan Mode\n")
        Config.maxDepth = 3
        Config.deepFunctionAnalysis = false
        return ExecuteAnalysis()
    end,
    
    DeepScan = function()
        print("\n🔬 Deep Scan Mode\n")
        Config.maxDepth = 10
        Config.deepFunctionAnalysis = true
        return ExecuteAnalysis()
    end,
    
    ExploitScan = function()
        print("\n🔓 Exploit-Focused Scan\n")
        Config.maxDepth = 5
        local result = ExecuteAnalysis()
        return result and result.exploits or {}
    end,
    
    -- Export function
    ExportToFile = function(filename, data)
        return FileSystem:WriteJSON(filename, data)
    end,
    
    -- Config access
    GetConfig = function()
        return Config
    end,
    
    SetConfig = function(key, value)
        if Config[key] ~= nil then
            Config[key] = value
            return true
        end
        return false
    end
}

-- ========================================
-- AUTO-EXECUTION
-- ========================================

print([[

╔═══════════════════════════════════════════╗
║         🎮 COMMANDS AVAILABLE 🎮         ║
╚═══════════════════════════════════════════╝

AUTOMATIC MODE:
  Just wait, analysis will auto-start!

MANUAL COMMANDS:
  _G.UltimateAnalyzer.Run()           -- Full analysis
  _G.UltimateAnalyzer.QuickScan()     -- Fast scan
  _G.UltimateAnalyzer.DeepScan()      -- Deep scan
  _G.UltimateAnalyzer.ExploitScan()   -- Find exploits only

UTILITY COMMANDS:
  _G.UltimateAnalyzer.ListAllModules()
  _G.UltimateAnalyzer.AnalyzeModule("WeightRandom")
  _G.UltimateAnalyzer.FindWeightTables()
  _G.UltimateAnalyzer.FindRNGFunctions()
  _G.UltimateAnalyzer.MonitorRemotes()

ADVANCED:
  _G.UltimateAnalyzer.GetConfig()
  _G.UltimateAnalyzer.SetConfig("maxDepth", 5)
  _G.UltimateAnalyzer.ExportToFile("custom.json", data)

📂 All files saved to: Hydrogen/dump/
   • complete_analysis.json
   • complete_analysis.lua
   • Modules/*.json
   • Patterns/*.json
   • Exploits/all_vulnerabilities.json
   • Remotes/remote_events.json
   • Reports/*.txt

════════════════════════════════════════════
]])

-- Auto-run with delay
print("\n⏳ Starting ULTIMATE analysis in 3 seconds...")
print("💡 Tip: You can cancel and run manually with _G.UltimateAnalyzer.Run()\n")

task.wait(3)

-- Execute analysis
local result = ExecuteAnalysis()

if result then
    print("\n" .. string.rep("=", 60))
    print("🎉 ANALYSIS COMPLETE!")
    print(string.rep("=", 60))
    print("\n📂 Check Hydrogen/dump/ folder for all results")
    print("📊 Use _G.UltimateAnalyzer API for more features\n")
else
    warn("\n⚠️ Analysis failed - check errors above")
end

return _G.UltimateAnalyzer
