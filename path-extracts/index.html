<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Path Extractor | Pentester Tools</title>
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }
            body {
                font-family: "Courier New", "Monaco", monospace;
                background: linear-gradient(135deg, #0f0f0f 0%, #1a1a2e 100%);
                color: #00ff88;
                min-height: 100vh;
                line-height: 1.6;
            }
            .navbar {
                background: rgba(0, 0, 0, 0.9);
                backdrop-filter: blur(10px);
                border-bottom: 2px solid #00ff88;
                padding: 1rem 0;
                position: fixed;
                top: 0;
                width: 100%;
                z-index: 1000;
                box-shadow: 0 2px 20px rgba(0, 255, 136, 0.3);
            }
            .nav-container {
                max-width: 1200px;
                margin: 0 auto;
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 0 2rem;
            }
            .logo {
                font-size: 1.5rem;
                font-weight: bold;
                color: #00ff88;
                text-shadow: 0 0 10px #00ff88;
            }
            .nav-links {
                display: flex;
                list-style: none;
                gap: 2rem;
            }
            .nav-links a {
                color: #888;
                text-decoration: none;
                padding: 0.5rem 1rem;
                border-radius: 5px;
                transition: all 0.3s ease;
                border: 1px solid transparent;
            }
            .nav-links a:hover,
            .nav-links a.active {
                color: #00ff88;
                border-color: #00ff88;
                box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
                text-shadow: 0 0 5px #00ff88;
            }
            /* Main Content */
            .main-content {
                margin-top: 100px;
                padding: 2rem;
                max-width: 1200px;
                margin-left: auto;
                margin-right: auto;
            }
            .hero-section {
                text-align: center;
                padding: 2rem 0;
                margin-bottom: 2rem;
            }
            .hero-title {
                font-size: 2.5rem;
                margin-bottom: 1rem;
                text-shadow: 0 0 20px #00ff88;
                animation: glow 2s ease-in-out infinite alternate;
            }
            .hero-subtitle {
                font-size: 1.2rem;
                color: #888;
                margin-bottom: 2rem;
            }
            .tool-container {
                background: rgba(0, 0, 0, 0.7);
                border: 1px solid #333;
                border-radius: 10px;
                padding: 2rem;
                margin-bottom: 2rem;
                transition: all 0.3s ease;
                position: relative;
                overflow: hidden;
            }
            .tool-container::before {
                content: "";
                position: absolute;
                top: 0;
                left: -100%;
                width: 100%;
                height: 2px;
                background: linear-gradient(90deg, transparent, #00ff88, transparent);
                transition: left 0.5s;
            }
            .tool-container:hover {
                border-color: #00ff88;
                box-shadow: 0 5px 25px rgba(0, 255, 136, 0.2);
            }
            .tool-container:hover::before {
                left: 100%;
            }
            .section-title {
                font-size: 1.5rem;
                color: #00ff88;
                margin-bottom: 1.5rem;
                display: flex;
                align-items: center;
                gap: 0.5rem;
            }
            textarea {
                width: 100%;
                height: 180px;
                padding: 1rem;
                font-family: "Courier New", monospace;
                background: rgba(0, 0, 0, 0.5);
                border: 1px solid #333;
                border-radius: 8px;
                color: #00ff88;
                resize: vertical;
                transition: all 0.3s ease;
            }
            textarea:focus {
                outline: none;
                border-color: #00ff88;
                box-shadow: 0 0 0 3px rgba(0, 255, 136, 0.2);
            }
            .stats {
                display: flex;
                gap: 1rem;
                margin: 1rem 0;
                flex-wrap: wrap;
            }
            .stat-item {
                background: rgba(0, 0, 0, 0.5);
                padding: 0.8rem 1rem;
                border-radius: 8px;
                border: 1px solid #333;
                flex-grow: 1;
                min-width: 120px;
            }
            .stat-number {
                font-weight: bold;
                color: #00ff88;
                font-size: 1.2rem;
            }
            .button-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 1rem;
                margin: 1.5rem 0;
            }
            .button {
                padding: 0.8rem 1.5rem;
                background: transparent;
                border: 1px solid #00ff88;
                color: #00ff88;
                border-radius: 5px;
                cursor: pointer;
                transition: all 0.3s ease;
                font-family: inherit;
                text-align: center;
            }
            .button:hover {
                background: #00ff88;
                color: #000;
                box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
            }
            .button.danger {
                border-color: #ff5555;
                color: #ff5555;
            }
            .button.danger:hover {
                background: #ff5555;
                color: #000;
                box-shadow: 0 0 20px rgba(255, 85, 85, 0.5);
            }
            .button.success {
                border-color: #55ff55;
                color: #55ff55;
            }
            .button.success:hover {
                background: #55ff55;
                color: #000;
                box-shadow: 0 0 20px rgba(85, 255, 85, 0.5);
            }
            .action-buttons {
                display: flex;
                gap: 1rem;
                margin-bottom: 1rem;
                flex-wrap: wrap;
            }
            .action-btn {
                padding: 0.6rem 1rem;
                background: rgba(0, 0, 0, 0.5);
                border: 1px solid #333;
                color: #00ff88;
                border-radius: 5px;
                cursor: pointer;
                transition: all 0.3s ease;
                font-family: inherit;
            }
            .action-btn:hover {
                border-color: #00ff88;
                box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
            }
            .status-bar {
                background: rgba(0, 0, 0, 0.9);
                padding: 1rem;
                margin-top: 2rem;
                border-radius: 10px;
                border: 1px solid #333;
                font-family: "Courier New", monospace;
                color: #888;
            }
            .status-indicator {
                display: inline-block;
                width: 10px;
                height: 10px;
                background: #00ff88;
                border-radius: 50%;
                margin-right: 0.5rem;
                animation: pulse 1s infinite;
            }
            .toast {
                position: fixed;
                top: 20px;
                right: 20px;
                max-width: 350px;
                width: auto;
                background: rgba(0, 0, 0, 0.9);
                border: 1px solid #00ff88;
                color: #00ff88;
                padding: 0.8rem 1.2rem;
                border-radius: 6px;
                box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
                transform: translateX(150%);
                transition: transform 0.3s ease;
                z-index: 1000;
                word-break: break-word;
                font-size: 0.9rem;
            }
            .toast.show {
                transform: translateX(0);
            }
            .toggle-container {
                display: flex;
                align-items: center;
                margin-bottom: 15px;
            }
            .toggle-label {
                margin-right: 10px;
                color: #00ff88;
            }
            .toggle-switch {
                position: relative;
                display: inline-block;
                width: 60px;
                height: 30px;
            }
            .toggle-switch input {
                opacity: 0;
                width: 0;
                height: 0;
            }
            .slider {
                position: absolute;
                cursor: pointer;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-color: #333;
                transition: 0.4s;
                border-radius: 34px;
            }
            .slider:before {
                position: absolute;
                content: "";
                height: 22px;
                width: 22px;
                left: 4px;
                bottom: 4px;
                background-color: #00ff88;
                transition: 0.4s;
                border-radius: 50%;
            }
            input:checked + .slider {
                background-color: #333;
            }
            input:checked + .slider:before {
                transform: translateX(30px);
            }
            @keyframes glow {
                from {
                    text-shadow: 0 0 20px #00ff88;
                }
                to {
                    text-shadow: 0 0 30px #00ff88, 0 0 40px #00ff88;
                }
            }
            @keyframes pulse {
                0% {
                    opacity: 1;
                }
                50% {
                    opacity: 0.5;
                }
                100% {
                    opacity: 1;
                }
            }
            @media (max-width: 768px) {
                .nav-container {
                    flex-direction: column;
                    gap: 1rem;
                }
                .toast {
                    top: 10px;
                    right: 10px;
                    left: 10px;
                    max-width: calc(100% - 20px);
                    padding: 0.8rem 1rem;
                    font-size: 0.9rem;
                }
                .nav-links {
                    gap: 1rem;
                }
                .hero-title {
                    font-size: 2rem;
                }
                .button-grid {
                    grid-template-columns: 1fr;
                }
            }
        </style>
    </head>
    <body>
    <!-- Navbar -->
    <nav class="navbar">
        <div class="nav-container">
            <div class="logo">🔒 PENTESTER TOOLS</div>
            <ul class="nav-links">
                <li>
                    <a href="/" class="nav-link" data-section="home">Home</a>
                </li>
                <li>
                    <a href="/uri" class="nav-link" data-section="uri">URI Manager</a>
                </li>
                <li>
                    <a href="/path-extracts" class="nav-link active" data-section="path-extracts">Path Extractor</a>
                </li>
                <li>
                    <a href="/dork" class="nav-link" data-section="dork">Auto Dorking</a>
                </li>
            </ul>
        </div>
    </nav>

    <!-- Main Content -->
    <main class="main-content">
        <!-- Hero Section -->
        <section class="hero-section">
            <h1 class="hero-title">ADVANCED PATH EXTRACTOR</h1>
            <p class="hero-subtitle">Extract and clean URL paths with advanced filtering options</p>
        </section>

        <!-- Tool Container -->
        <div class="tool-container">
            <div class="section-title">📝 Input URLs/Paths</div>
            <textarea
                id="urls"
                placeholder="Paste your list of URLs or paths here, one per line...&#10;&#10;Examples:&#10;https://www.example.com/page?param=value&#10;http://subdomain.example.org/folder/file.html&#10;www.another-example.com/api/v1/users&#10;just-domain.net/admin/login&#10;/api/users&#10;about-us&#10;components"
            ></textarea>
            <div class="stats">
                <div class="stat-item">
                    <div class="stat-number" id="totalLines">0</div>
                    <div>Total Lines</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="validUrls">0</div>
                    <div>Valid URLs</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="uniqueDomains">0</div>
                    <div>Unique Domains</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="pathCount">0</div>
                    <div>Path Segments</div>
                </div>
            </div>
        </div>

        <!-- Filter Options -->
        <div class="tool-container">
            <div class="section-title">⚙️ Extraction Options</div>
            <div class="toggle-container">
                <span class="toggle-label">Exclude Query Strings:</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="excludeQueries" checked />
                    <span class="slider"></span>
                </label>
            </div>
            <div class="toggle-container">
                <span class="toggle-label">Exclude File Extensions:</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="excludeExtensions" checked />
                    <span class="slider"></span>
                </label>
            </div>
            <div class="toggle-container">
                <span class="toggle-label">Exclude Article Paths (multi-hyphen):</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="excludeArticles" checked />
                    <span class="slider"></span>
                </label>
            </div>
            <div class="toggle-container">
                <span class="toggle-label">Exclude Parameter Values:</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="excludeParamValues" checked />
                    <span class="slider"></span>
                </label>
            </div>
            <div class="toggle-container">
                <span class="toggle-label">Split Path Segments:</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="splitSegments" checked />
                    <span class="slider"></span>
                </label>
            </div>
            <div class="button-grid">
                <button class="button" id="extractPathsBtn">🔍 Extract Path Segments</button>
                <button class="button" id="extractFullPathsBtn">✨ Extract Full Paths</button>
                <button class="button" id="extractDomainsBtn">🌐 Extract Domains</button>
                <button class="button danger" id="clearAllBtn">🗑️ Clear All</button>
            </div>
        </div>

        <!-- Path Manipulation Tools -->
        <div class="tool-container">
            <div class="section-title">🔧 Path Manipulation Tools</div>
            <div class="button-grid">
                <button class="button" id="removeSlashBtn">➖ Remove Leading/Trailing Slash</button>
                <button class="button" id="addLeadingSlashBtn">➕ Add Leading Slash</button>
                <button class="button" id="addTrailingSlashBtn">➕ Add Trailing Slash</button>
                <button class="button success" id="removeDuplicatesBtn">🔄 Remove Duplicates</button>
            </div>
        </div>

        <!-- Results Section -->
        <div class="tool-container">
            <div class="section-title">✨ Extracted Path Segments</div>
            <div class="action-buttons">
                <button class="action-btn" id="copyResultsBtn">📋 Copy Results</button>
                <button class="action-btn" id="downloadResultsBtn">💾 Download as TXT</button>
                <button class="action-btn" id="countResultsBtn">🔢 Count Results</button>
                <button class="action-btn" id="cleanPathsBtn">🧹 Clean Paths</button>
            </div>
            <textarea id="cleanedUrls" readonly placeholder="Your extracted path segments will appear here..."></textarea>
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            <span class="status-indicator"></span>
            <strong>System Status:</strong> Operational |
            <strong>Last Update:</strong> <span id="currentDate"></span>
        </div>
    </main>

    <!-- Toast Notification -->
    <div class="toast" id="toast"></div>

    <script>
        // Update current date
        document.getElementById("currentDate").textContent = new Date().toLocaleString();

        // Show toast notification
        function showToast(message, duration = 3000) {
            const toast = document.getElementById("toast");
            toast.textContent = message;
            toast.classList.add("show");
            setTimeout(() => {
                toast.classList.remove("show");
            }, duration);
        }

        function copyResults() {
            const cleanedUrls = document.getElementById("cleanedUrls");
            cleanedUrls.select();
            document.execCommand("copy");
            showToast("Results copied to clipboard!");
        }

        function downloadResults() {
            const cleanedUrls = document.getElementById("cleanedUrls").value;
            if (!cleanedUrls.trim()) {
                showToast("No results to download!");
                return;
            }

            const blob = new Blob([cleanedUrls], { type: "text/plain" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "extracted_paths.txt";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showToast("Results downloaded!");
        }

        // Count results
        function countResults() {
            const cleanedUrls = document.getElementById("cleanedUrls").value;
            const count = cleanedUrls.trim() ? cleanedUrls.split("\n").length : 0;
            showToast(`Found ${count} path segments in results`);
        }

        // Clear all inputs and results
        function clearAll() {
            document.getElementById("urls").value = "";
            document.getElementById("cleanedUrls").value = "";
            updateStats();
            showToast("Cleared all inputs and results");
        }

        // Update statistics
        function updateStats() {
            const urls = document.getElementById("urls").value;
            const lines = urls.trim() ? urls.split("\n").length : 0;

            // Count valid URLs (very basic validation)
            let validCount = 0;
            if (urls.trim()) {
                validCount = urls.split("\n").filter((line) => {
                    return line.trim() && (line.includes("://") || line.includes(".") || line.startsWith("/"));
                }).length;
            }

            // Count unique domains
            let domains = new Set();
            if (urls.trim()) {
                urls.split("\n").forEach((line) => {
                    try {
                        if (line.includes("://")) {
                            const url = new URL(line.startsWith("http") ? line : "http://" + line);
                            domains.add(url.hostname);
                        } else if (line.includes("/")) {
                            const domain = line.split("/")[0];
                            if (domain.includes(".")) {
                                domains.add(domain);
                            }
                        } else if (line.includes(".")) {
                            domains.add(line);
                        }
                    } catch (e) {
                    }
                });
            }

            // Count path segments
            let pathCount = 0;
            const cleanedUrls = document.getElementById("cleanedUrls").value;
            if (cleanedUrls.trim()) {
                pathCount = cleanedUrls.split("\n").length;
            }

            document.getElementById("totalLines").textContent = lines;
            document.getElementById("validUrls").textContent = validCount;
            document.getElementById("uniqueDomains").textContent = domains.size;
            document.getElementById("pathCount").textContent = pathCount;
        }

        document.getElementById("urls").addEventListener("input", updateStats);
        document.getElementById("cleanedUrls").addEventListener("input", updateStats);

        function containsDots(segment) {
            return segment.includes(".");
        }

        function isTokenOrEncoded(segment) {
            if (segment.startsWith("eyJ") || segment.startsWith("eyj")) {
                return true;
            }

            if (segment.match(/^[A-Za-z0-9+\/=]{20,}$/)) {
                return true;
            }

            if (segment.includes("%") && segment.match(/%[0-9A-Fa-f]{2}/)) {
                return true;
            }

            return false;
        }

        function removeExtensions(path) {
            return path.replace(/\.(php|js|html|htm|asp|aspx|jsp|pdf|doc|docx|xls|xlsx|txt|xml|json|css|png|jpg|jpeg|gif|bmp|svg|ico|mp3|mp4|avi|mov|zip|rar|tar|gz|exe|dll|bat|sh|py|rb|pl|java|cpp|c|h|log|tmp|bak|swp|cache)$/i, "");
        }

        function isArticleSlug(segment) {
            const cleanSegment = segment.replace(/^\//, "");
            const hyphenCount = (cleanSegment.match(/-/g) || []).length;
            return hyphenCount >= 2;
        }

        function removeColonParams(segment) {
            return segment.replace(/:.*$/, "");
        }

        function hasInvalidChars(segment) {
            return segment.includes("&") || segment.includes("=");
        }

        function isDataUriOrEncoded(segment) {
            const decodedSegment = decodeURIComponent(segment);
            return decodedSegment.includes("data:image/") || decodedSegment.includes("base64,") || segment.includes("%22data:") || segment.includes("%3Cp%3E");
        }

        function cleanParameterValues(url) {
            try {
                if (url.includes("?")) {
                    const [baseUrl, queryString] = url.split("?");
                    const params = queryString.split("&");

                    const cleanedParams = params
                        .map((param) => {
                            const [key] = param.split("=");
                            return key || "";
                        })
                        .filter((param) => param);

                    return baseUrl + (cleanedParams.length > 0 ? "?" + cleanedParams.join("&") : "");
                }
                return url;
            } catch (e) {
                return url;
            }
        }

        // Enhanced function to check if path should be removed
        function shouldRemovePath(path) {
            // Remove paths with dots (files, version numbers, etc.)
            if (containsDots(path)) {
                return true;
            }

            if (isTokenOrEncoded(path)) {
                return true;
            }

            if (path.match(/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/i) || path.match(/_[A-F0-9]{8}_[A-F0-9]{4}_[A-F0-9]{4}_[A-F0-9]{4}_[A-F0-9]{12}/i)) {
                return true;
            }

            if (path.match(/[0-9a-f]{32,}/i)) {
                return true;
            }

            if (path.match(/\/0\.\d+/)) {
                return true;
            }

            if (path.match(/^\/_xlnm\./i)) {
                return true;
            }

            if (path.match(/\/\d+\.\d+(em|rem|px|pt)/i)) {
                return true;
            }

            if (path.match(/[\/;%]/) && !path.match(/^\/[a-zA-Z0-9\-_~\/]+$/)) {
                return true;
            }

            const underscoreCount = (path.match(/_/g) || []).length;
            if (underscoreCount > 2) {
                return true;
            }

            const unwantedPatterns = [
                "Symbol.iterator",
                "swiper-bundle.min",
                "swiper.min",
                "PERCENTILE",
                "PERCENTRANK",
                "playList.selectedIndex",
                "plugin.dev",
                "plugin.min",
                "plugins.",
                "Math.sign",
                "Material.toJSON",
                "PIVOT.FIELD",
                "PIVOT.ITEM",
                "PIVOT.REFRESH",
                "modernizr.mod",
            ];

            for (const pattern of unwantedPatterns) {
                if (path.includes(pattern)) {
                    return true;
                }
            }

            return false;
        }

        function shouldRemoveSegment(segment) {
            if (containsDots(segment)) {
                return true;
            }

            if (isTokenOrEncoded(segment)) {
                return true;
            }

            if (
                segment.match(/^[A-Za-z0-9+\/=]{20,}$/) || // Base64-like
                segment.match(/[0-9a-f]{32,}/i) || // Long hex
                segment.match(/^\d+$/) || // Purely numeric
                segment.includes("Symbol.") ||
                segment.includes("Math.") ||
                segment.includes("Material.") ||
                segment.includes("PIVOT.") ||
                segment.includes("modernizr.")
            ) {
                return true;
            }

            return false;
        }

        // New path manipulation functions
        function removeSlash() {
            const results = document.getElementById("cleanedUrls").value.trim();
            if (!results) {
                showToast("No results to process!");
                return;
            }

            const lines = results.split("\n");
            const processed = lines.map(line => {
                let processedLine = line.trim();
                // Remove leading slash
                if (processedLine.startsWith("/")) {
                    processedLine = processedLine.substring(1);
                }
                // Remove trailing slash
                if (processedLine.endsWith("/")) {
                    processedLine = processedLine.substring(0, processedLine.length - 1);
                }
                return processedLine;
            }).filter(line => line); // Remove empty lines

            document.getElementById("cleanedUrls").value = processed.join("\n");
            updateStats();
            showToast(`Removed leading/trailing slashes from ${processed.length} paths!`);
        }

        function addLeadingSlash() {
            const results = document.getElementById("cleanedUrls").value.trim();
            if (!results) {
                showToast("No results to process!");
                return;
            }

            const lines = results.split("\n");
            const processed = lines.map(line => {
                let processedLine = line.trim();
                if (processedLine && !processedLine.startsWith("/")) {
                    processedLine = "/" + processedLine;
                }
                return processedLine;
            }).filter(line => line); // Remove empty lines

            document.getElementById("cleanedUrls").value = processed.join("\n");
            updateStats();
            showToast(`Added leading slash to ${processed.length} paths!`);
        }

        function addTrailingSlash() {
            const results = document.getElementById("cleanedUrls").value.trim();
            if (!results) {
                showToast("No results to process!");
                return;
            }

            const lines = results.split("\n");
            const processed = lines.map(line => {
                let processedLine = line.trim();
                if (processedLine && !processedLine.endsWith("/")) {
                    processedLine = processedLine + "/";
                }
                return processedLine;
            }).filter(line => line); // Remove empty lines

            document.getElementById("cleanedUrls").value = processed.join("\n");
            updateStats();
            showToast(`Added trailing slash to ${processed.length} paths!`);
        }

        function removeDuplicates() {
            const results = document.getElementById("cleanedUrls").value.trim();
            if (!results) {
                showToast("No results to process!");
                return;
            }

            const lines = results.split("\n");
            const originalCount = lines.length;
            const uniqueLines = [...new Set(lines.map(line => line.trim()))].filter(line => line);
            const duplicatesRemoved = originalCount - uniqueLines.length;

            document.getElementById("cleanedUrls").value = uniqueLines.join("\n");
            updateStats();
            showToast(`Removed ${duplicatesRemoved} duplicates! ${uniqueLines.length} unique paths remaining.`);
        }

        function cleanPaths() {
            const results = document.getElementById("cleanedUrls").value.trim();
            if (!results) {
                showToast("No results to process!");
                return;
            }

            const lines = results.split("\n");
            const cleaned = lines.map(line => {
                let processedLine = line.trim();
                
                // Clean the path segment
                if (shouldRemoveSegment(processedLine)) {
                    return null;
                }
                
                // Remove extensions if needed
                if (document.getElementById("excludeExtensions").checked) {
                    processedLine = removeExtensions(processedLine);
                }
                
                // Remove colon parameters
                processedLine = removeColonParams(processedLine);
                
                // Remove article paths if needed
                if (document.getElementById("excludeArticles").checked && isArticleSlug(processedLine)) {
                    return null;
                }
                
                return processedLine;
            }).filter(line => line); // Remove null/empty lines

            document.getElementById("cleanedUrls").value = cleaned.join("\n");
            updateStats();
            showToast(`Cleaned ${cleaned.length} paths!`);
        }

        function isPathSegment(input) {
            // Check if it's a simple path segment (not a URL)
            return !input.includes("://") && 
                   !input.includes(".") && 
                   !input.includes("?") && 
                   !input.includes("#") && 
                   input.trim().length > 0;
        }

        function extractPathSegments() {
            const input = document.getElementById("urls").value.trim();
            if (!input) {
                showToast("Please enter some URLs or paths first!");
                return;
            }

            const excludeQueries = document.getElementById("excludeQueries").checked;
            const excludeExtensions = document.getElementById("excludeExtensions").checked;
            const excludeArticles = document.getElementById("excludeArticles").checked;
            const excludeParamValues = document.getElementById("excludeParamValues").checked;
            const splitSegments = document.getElementById("splitSegments").checked;

            const urls = input.split("\n");
            const extractedSegments = new Set();

            extractedSegments.add("/");

            urls.forEach((line) => {
                line = line.trim();
                if (!line) return;

                // Check if this is just a path segment (not a full URL)
                if (isPathSegment(line)) {
                    if (!shouldRemoveSegment(line)) {
                        extractedSegments.add("/" + line);
                    }
                    return;
                }

                try {
                    let path = "";
                    let query = "";

                    if (excludeParamValues) {
                        line = cleanParameterValues(line);
                    }

                    // Handle full URLs
                    if (line.includes("://")) {
                        const url = new URL(line.startsWith("http") ? line : "http://" + line);
                        path = url.pathname;
                        query = url.search;
                    } 
                    // Handle paths starting with /
                    else if (line.startsWith("/")) {
                        const parts = line.split("?");
                        path = parts[0];
                        query = parts[1] ? "?" + parts[1] : "";
                    } 
                    // Handle domain/path format
                    else if (line.includes("/")) {
                        const parts = line.split("?");
                        path = parts[0].startsWith("/") ? parts[0] : "/" + parts[0];
                        query = parts[1] ? "?" + parts[1] : "";
                    } 
                    // Handle plain path segments (like "about-us", "api", etc.)
                    else {
                        path = "/" + line;
                    }

                    path = path.replace(/\/+/g, "/");
                    if (path.length > 1 && path.endsWith("/")) {
                        path = path.slice(0, -1);
                    }

                    if (!path) path = "/";

                    if (hasInvalidChars(path)) {
                        return;
                    }

                    if (isDataUriOrEncoded(path)) {
                        return;
                    }

                    if (shouldRemovePath(path)) {
                        return;
                    }

                    if (excludeExtensions) {
                        path = removeExtensions(path);
                    }

                    if (excludeArticles && isArticleSlug(path)) {
                        return;
                    }

                    path = removeColonParams(path);

                    if (!splitSegments) {
                        extractedSegments.add(path);
                        return;
                    }

                    const segments = path.split("/").filter((segment) => segment.trim() !== "");

                    for (const segment of segments) {
                        let processedSegment = segment;

                        if (shouldRemoveSegment(processedSegment)) {
                            continue;
                        }

                        if (hasInvalidChars(processedSegment)) {
                            continue;
                        }

                        if (isDataUriOrEncoded(processedSegment)) {
                            continue;
                        }

                        if (excludeExtensions) {
                            processedSegment = removeExtensions(processedSegment);
                        }

                        if (excludeArticles && isArticleSlug(processedSegment)) {
                            continue;
                        }

                        processedSegment = removeColonParams(processedSegment);

                        if (!processedSegment) continue;

                        extractedSegments.add("/" + processedSegment);
                    }

                    if (!excludeQueries && query) {
                        const queryParams = query.slice(1).split("&");
                        for (const param of queryParams) {
                            const [key] = param.split("=");
                            if (key && !shouldRemoveSegment(key)) {
                                extractedSegments.add("?" + key);
                                if (!excludeParamValues) {
                                    extractedSegments.add("?" + param);
                                }
                            }
                        }
                    }
                } catch (e) {
                    console.error("Error processing URL:", line, e);
                }
            });

            const sortedSegments = Array.from(extractedSegments).sort((a, b) => a.localeCompare(b));

            document.getElementById("cleanedUrls").value = sortedSegments.join("\n");
            updateStats();
            showToast(`Extracted ${sortedSegments.length} path segments!`);
        }

        function extractFullPaths() {
            const input = document.getElementById("urls").value.trim();
            if (!input) {
                showToast("Please enter some URLs or paths first!");
                return;
            }

            const excludeQueries = document.getElementById("excludeQueries").checked;
            const excludeExtensions = document.getElementById("excludeExtensions").checked;
            const excludeArticles = document.getElementById("excludeArticles").checked;
            const excludeParamValues = document.getElementById("excludeParamValues").checked;

            const urls = input.split("\n");
            const extractedPaths = new Set();

            urls.forEach((line) => {
                line = line.trim();
                if (!line) return;

                // Check if this is just a path segment (not a full URL)
                if (isPathSegment(line)) {
                    if (!shouldRemoveSegment(line)) {
                        extractedPaths.add("/" + line);
                    }
                    return;
                }

                try {
                    let path = "";
                    let query = "";

                    // Clean parameter values if needed
                    if (excludeParamValues) {
                        line = cleanParameterValues(line);
                    }

                    // Parse URL to extract path
                    if (line.includes("://")) {
                        const url = new URL(line.startsWith("http") ? line : "http://" + line);
                        path = url.pathname;
                        query = url.search;
                    } else if (line.startsWith("/")) {
                        const parts = line.split("?");
                        path = parts[0];
                        query = parts[1] ? "?" + parts[1] : "";
                    } else if (line.includes("/")) {
                        const parts = line.split("?");
                        path = parts[0].startsWith("/") ? parts[0] : "/" + parts[0];
                        query = parts[1] ? "?" + parts[1] : "";
                    } else {
                        path = "/" + line;
                    }

                    path = path.replace(/\/+/g, "/");
                    if (path.length > 1 && path.endsWith("/")) {
                        path = path.slice(0, -1);
                    }

                    if (!path) path = "/";

                    if (hasInvalidChars(path)) {
                        return;
                    }

                    if (isDataUriOrEncoded(path)) {
                        return;
                    }

                    if (shouldRemovePath(path)) {
                        return;
                    }

                    if (excludeExtensions) {
                        path = removeExtensions(path);
                    }

                    if (excludeArticles && isArticleSlug(path)) {
                        return;
                    }

                    path = removeColonParams(path);

                    let fullPath = path;
                    if (!excludeQueries && query) {
                        fullPath += query;
                    }

                    extractedPaths.add(fullPath);
                } catch (e) {
                    console.error("Error processing URL:", line, e);
                }
            });

            const sortedPaths = Array.from(extractedPaths).sort();
            document.getElementById("cleanedUrls").value = sortedPaths.join("\n");
            updateStats();
            showToast(`Extracted ${sortedPaths.length} full paths!`);
        }

        function extractDomains() {
            const input = document.getElementById("urls").value.trim();
            if (!input) {
                showToast("Please enter some URLs first!");
                return;
            }

            const urls = input.split("\n");
            const domains = new Set();

            urls.forEach((line) => {
                line = line.trim();
                if (!line) return;

                try {
                    if (line.includes("://")) {
                        const url = new URL(line.startsWith("http") ? line : "http://" + line);
                        domains.add(url.hostname);
                    } else if (line.includes("/")) {
                        const domain = line.split("/")[0];
                        if (domain.includes(".")) {
                            domains.add(domain);
                        }
                    } else if (line.includes(".")) {
                        domains.add(line);
                    }
                } catch (e) {
                    console.error("Error processing URL:", line, e);
                }
            });

            const sortedDomains = Array.from(domains).sort();
            document.getElementById("cleanedUrls").value = sortedDomains.join("\n");
            updateStats();
            showToast(`Extracted ${sortedDomains.length} domains!`);
        }

        // Event listeners
        document.getElementById("extractPathsBtn").addEventListener("click", extractPathSegments);
        document.getElementById("extractFullPathsBtn").addEventListener("click", extractFullPaths);
        document.getElementById("extractDomainsBtn").addEventListener("click", extractDomains);
        document.getElementById("clearAllBtn").addEventListener("click", clearAll);
        document.getElementById("copyResultsBtn").addEventListener("click", copyResults);
        document.getElementById("downloadResultsBtn").addEventListener("click", downloadResults);
        document.getElementById("countResultsBtn").addEventListener("click", countResults);
        document.getElementById("cleanPathsBtn").addEventListener("click", cleanPaths);

        // New event listeners for path manipulation
        document.getElementById("removeSlashBtn").addEventListener("click", removeSlash);
        document.getElementById("addLeadingSlashBtn").addEventListener("click", addLeadingSlash);
        document.getElementById("addTrailingSlashBtn").addEventListener("click", addTrailingSlash);
        document.getElementById("removeDuplicatesBtn").addEventListener("click", removeDuplicates);
    </script>
</body>
</html>
